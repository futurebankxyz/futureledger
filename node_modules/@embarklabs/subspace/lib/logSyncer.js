import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import { fromEvent, ReplaySubject } from 'rxjs';
import hash from 'object-hash';

var LogSyncer =
/*#__PURE__*/
function () {
  function LogSyncer(web3, events, db) {
    var _this = this;

    _classCallCheck(this, LogSyncer);

    _defineProperty(this, "_parseEventCBFactory", function (filterConditions, eventKey) {
      return function (err, ev) {
        if (err) {
          throw new Error(err);
        }

        if (filterConditions) {
          if (filterConditions.address && ev.address.toLowerCase() !== filterConditions.address.toLowerCase()) return;

          if (filterConditions.topics) {
            var _context;

            var shouldSkip = false;

            _forEachInstanceProperty(_context = filterConditions.topics).call(_context, function (topic, i) {
              if (topic != null && (!ev.topics[i] || ev.topics[i].toLowerCase() !== topic.toLowerCase())) {
                shouldSkip = true;
              }
            });

            if (shouldSkip) return;
          }
        }

        _this.events.emit(eventKey, ev);
      };
    });

    this.events = events;
    this.web3 = web3;
    this.db = db;
    this.subscriptions = [];
  }

  _createClass(LogSyncer, [{
    key: "track",
    value: function track(options, inputsABI, gteBlockNum, networkId) {
      var _this2 = this;

      var eventKey = 'logs-' + hash(_Object$assign({
        networkId: networkId
      }, options || {}));

      var filterConditions = _Object$assign({
        fromBlock: 0,
        toBlock: "latest"
      }, options || {});

      this.db.deleteNewestBlocks(eventKey, gteBlockNum);
      var eventSummary = this.db.getLastKnownEvent(eventKey);
      var sub = new ReplaySubject();
      var logObserver = fromEvent(this.events, eventKey);
      logObserver.subscribe(function (e) {
        if (!e) return;
        var id = hash({
          eventName: eventKey,
          blockNumber: e.blockNumber,
          transactionIndex: e.transactionIndex,
          logIndex: e.logIndex
        }); // TODO: would be nice if this was smart enough to understand the type of returnValues and do the needed conversions

        var eventData = {
          id: hash({
            eventName: eventKey,
            blockNumber: e.blockNumber,
            transactionIndex: e.transactionIndex,
            logIndex: e.logIndex
          }),
          data: e.data,
          address: e.address,
          topics: e.topics,
          removed: e.removed
        };
        var obsData = {
          blockNumber: e.blockNumber,
          data: e.data,
          address: e.address,
          topics: e.topics
        };

        if (inputsABI) {
          var _context2;

          eventData.returnValues = web3.eth.abi.decodeLog(inputsABI, e.data, _sliceInstanceProperty(_context2 = e.topics).call(_context2, 1));
          obsData.returnValues = eventData.returnValues;
        } // TODO: test reorgs


        sub.next(obsData);

        if (e.removed) {
          _this2.db.deleteEvent(eventKey, id);

          return;
        }

        if (_this2.db.eventExists(eventKey, eventData.id)) return;

        _this2.db.recordEvent(eventKey, eventData);

        _this2.events.emit("updateDB");
      });

      var eth_subscribe = this._retrieveEvents(eventKey, eventSummary.firstKnownBlock, eventSummary.lastKnownBlock, filterConditions);

      var og_subscribe = sub.subscribe;

      sub.subscribe = function (next, error, complete) {
        var s = og_subscribe.apply(sub, [next, error, complete]);
        s.add(function () {
          // Removing web3js subscription when rxJS unsubscribe is executed
          if (eth_subscribe) eth_subscribe.unsubscribe();
        });
        return s;
      };

      return sub;
    }
  }, {
    key: "_retrieveEvents",
    value: function _retrieveEvents(eventKey, firstKnownBlock, lastKnownBlock, filterConditions) {
      // TODO: this should be moved to a 'smart' module
      // it should be able to do events X at the time to avoid slow downs as well as the 10k limit
      if (firstKnownBlock == 0 || firstKnownBlock > 0 && firstKnownBlock <= filterConditions.fromBlock) {
        if (filterConditions.toBlock === 'latest') {
          // emit DB Events [fromBlock, lastKnownBlock]
          this._serveDBEvents(eventKey, filterConditions.fromBlock, lastKnownBlock, filterConditions); // create a event subscription [lastKnownBlock + 1, ...]


          var filters = _Object$assign({}, filterConditions, {
            fromBlock: filterConditions.fromBlock > lastKnownBlock ? filterConditions.fromBlock : lastKnownBlock + 1
          });

          return this._subscribeToEvent(filters, eventKey);
        } else if (filterConditions.toBlock <= lastKnownBlock) {
          // emit DB Events [fromBlock, toBlock]
          this._serveDBEvents(eventKey, filterConditions.fromBlock, filterConditions.toBlock, filterConditions);
        } else {
          // emit DB Events [fromBlock, lastKnownBlock]
          this._serveDBEvents(eventKey, filterConditions.fromBlock, lastKnownBlock, filterConditions); // create a past event subscription [lastKnownBlock + 1, toBlock]


          var _filters = _Object$assign({}, filterConditions, {
            fromBlock: filterConditions.fromBlock > lastKnownBlock ? filterConditions.fromBlock : lastKnownBlock + 1
          });

          this._getPastEvents(_filters, eventKey);
        }
      } else if (firstKnownBlock > 0) {
        // create a past event subscription [ firstKnownBlock > fromBlock ? fromBlock : 0, firstKnownBlock - 1]
        var fromBlock = firstKnownBlock > filterConditions.fromBlock ? filterConditions.fromBlock : 0;

        var _filters2 = _Object$assign({}, filterConditions, {
          fromBlock: fromBlock,
          toBlock: firstKnownBlock - 1
        });

        this._getPastEvents(_filters2, eventKey);

        if (filterConditions.toBlock === 'latest') {
          // emit DB Events [firstKnownBlock, lastKnownBlock]
          this._serveDBEvents(eventKey, firstKnownBlock, lastKnownBlock, filterConditions); // create a subscription [lastKnownBlock + 1, ...]


          var _filters3 = _Object$assign({}, filterConditions, {
            fromBlock: lastKnownBlock + 1
          });

          return this._subscribeToEvent(_filters3, eventKey);
        } else if (filterConditions.toBlock <= lastKnownBlock) {
          // emit DB Events [fromBlock, toBlock]
          this._serveDBEvents(eventKey, filterConditions.fromBlock, filterConditions.toBlock, filterConditions);
        } else {
          // emit DB Events [fromBlock, lastKnownBlock]
          this._serveDBEvents(eventKey, filterConditions.fromBlock, lastKnownBlock, filterConditions); // create a past event subscription [lastKnownBlock + 1, toBlock]


          var _filters4 = _Object$assign({}, filterConditions, {
            fromBlock: lastKnownBlock + 1,
            toBlock: filterConditions.toBlock
          });

          this._getPastEvents(_filters4, eventKey);
        }
      }
    }
  }, {
    key: "_serveDBEvents",
    value: function _serveDBEvents(eventKey, firstKnownBlock, lastKnownBlock, filterConditions) {
      var _context3;

      var cb = this._parseEventCBFactory(filterConditions, eventKey);

      var storedEvents = _filterInstanceProperty(_context3 = this.db.getEventsFor(eventKey)).call(_context3, function (x) {
        return x.blockNumber >= firstKnownBlock && x.blockNumber <= lastKnownBlock;
      });

      _forEachInstanceProperty(storedEvents).call(storedEvents, function (ev) {
        cb(null, ev);
      });
    }
  }, {
    key: "_getPastEvents",
    value: function _getPastEvents(filterConditions, eventKey) {
      var cb = this._parseEventCBFactory(filterConditions, eventKey);

      this.web3.getPastLogs(options, function (err, logs) {
        if (err) {
          throw new Error(err);
        }

        _forEachInstanceProperty(logs).call(logs, function (l) {
          cb(null, l);
        });
      });
    }
  }, {
    key: "_subscribeToEvent",
    value: function _subscribeToEvent(filterConditions, eventKey) {
      var s = this.web3.subscribe('logs', filterConditions, this._parseEventCBFactory(filterConditions, eventKey));
      this.subscriptions.push(s);
      return s;
    }
  }, {
    key: "close",
    value: function close() {
      var _context4;

      _forEachInstanceProperty(_context4 = this.subscriptions).call(_context4, function (x) {
        x.unsubscribe();
      });
    }
  }]);

  return LogSyncer;
}();

export default LogSyncer;
//# sourceMappingURL=logSyncer.js.map