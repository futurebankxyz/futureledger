{"version":3,"sources":["../src/httpEventScanner.js"],"names":["sleep","HttpEventScanner","web3","pollExecution","execId","fn","timeout","shouldStop","poll","serveDBEvents","getPastEvents","lastCachedBlock","filterConditions","push","maxBlockRange","getBlockNumber","lastBlockNumberAtLoad","toBlockFilter","toBlock","toBlockInPast","dbLimit","Math","min","fromBlock","max","maxBlock","toBlockLimit","console","log","toString","Array","length"],"mappings":"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","sourcesContent":["import {sleep} from './utils'\n\nclass HttpEventScanner {\n  constructor(web3){\n    this.pollExecution = [];\n    this.web3 = web3;\n  }\n\n  async poll(execId, fn, timeout){\n    const shouldStop = await fn();\n    if(!this.pollExecution[execId] || shouldStop) return;\n    if(timeout) await sleep(timeout * 1000);\n    await this.poll(execId, fn, timeout);\n  }\n\n  async scan(serveDBEvents, getPastEvents, lastCachedBlock, filterConditions) {\n    const execId = this.pollExecution.push(true) - 1;\n    const maxBlockRange = 500000; // TODO: extract to config\n    const lastBlockNumberAtLoad = await this.web3.getBlockNumber();\n\n    // If there's a toBlock with a number\n    let toBlockFilter = 0;\n    if(filterConditions.toBlock && filterConditions.toBlock !== 'latest' ){\n      toBlockFilter = filterConditions.toBlock;\n    }\n    const toBlockInPast =  toBlockFilter && toBlockFilter < lastBlockNumberAtLoad;\n\n    // Determine if data already exists and return it.\n    let dbLimit = toBlockFilter > 0 ? Math.min(toBlockFilter, lastCachedBlock) : lastCachedBlock;\n    if(lastCachedBlock > 0 && filterConditions.fromBlock >= 0){\n      serveDBEvents(filterConditions, dbLimit);\n      lastCachedBlock = lastCachedBlock + 1;\n    }\n    \n    lastCachedBlock = Math.max(lastCachedBlock, filterConditions.fromBlock||0);\n\n    // Get old events and store them in db\n    await this.poll(execId, async () => {\n      try {\n        const maxBlock = Math.min(lastCachedBlock + maxBlockRange, lastBlockNumberAtLoad);\n        const toBlock = toBlockInPast ? Math.min(maxBlock, toBlockFilter) : maxBlock;\n        const toBlockLimit = Math.min(await this.web3.getBlockNumber(), toBlock);  \n\n        if(toBlockLimit >= lastCachedBlock) {  \n          await getPastEvents(lastCachedBlock, toBlockLimit, toBlockInPast ? toBlockFilter : null);  \n          lastCachedBlock = toBlockLimit + 1;  \n        }\n      } catch (e) {  \n        console.log(e.toString());  \n      } \n\n      // Should exit?\n      return (toBlockInPast && lastCachedBlock >= (toBlockFilter || 0)) || (lastCachedBlock > Math.max(lastBlockNumberAtLoad, toBlockInPast ? toBlockFilter || 0 : 0));\n     });\n\n    if(toBlockInPast) return;\n\n    // Get new data, with a timeout between requests\n    await this.poll(execId, async () => {\n      try {\n        let toBlockLimit = await this.web3.getBlockNumber()\n        if(toBlockLimit >= lastCachedBlock) {  \n          await getPastEvents(lastCachedBlock, toBlockLimit, toBlockFilter || 0);  \n          lastCachedBlock = toBlockLimit + 1;  \n        }\n      } catch (e) {  \n        console.log(e.toString());  \n      } \n\n      // Should exit?\n      return filterConditions.toBlock !== 'latest' && lastCachedBlock > Math.max(lastBlockNumberAtLoad, toBlockFilter || 0);\n    }, 1);\n    \n  }\n\n  close(){\n    this.pollExecution = Array(this.pollExecution.length).fill(false);\n  }\n}\n\nexport default HttpEventScanner;\n"],"file":"httpEventScanner.js"}