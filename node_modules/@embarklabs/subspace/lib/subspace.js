import "core-js/modules/es.array.iterator";
import "core-js/modules/es.array.map";
import "core-js/modules/es.function.name";
import "core-js/modules/es.object.to-string";
import "core-js/modules/es.promise";
import "core-js/modules/es.string.iterator";
import "core-js/modules/web.dom-collections.iterator";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import _setInterval from "@babel/runtime-corejs3/core-js-stable/set-interval";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _findInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/find";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import "regenerator-runtime/runtime";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import { ReplaySubject, BehaviorSubject, Subject } from 'rxjs';
import { distinctUntilChanged, map } from 'rxjs/operators';
import equal from 'fast-deep-equal';
import Database from './database/database.js';
import NullDatabase from './database/nullDatabase.js';
import Events from 'events';
import Web3Eth from 'web3-eth';
import { isAddress } from './utils';
import stripHexPrefix from 'strip-hex-prefix';
import { hexToDec } from 'hex2dec';
import EventSyncer from './eventSyncer';
import LogSyncer from './logSyncer';
import hash from 'object-hash';

var Subspace =
/*#__PURE__*/
function () {
  function Subspace(provider) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Subspace);

    if (!provider.on) {
      // https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-subscriptions/src/subscription.js#L205
      console.warn("subspace: the current provider doesn't support subscriptions. Falling back to http polling");
    }

    this.events = new Events();
    this.web3 = new Web3Eth(provider);
    this.options = {};
    this.options.refreshLastNBlocks = options.refreshLastNBlocks || 12;
    this.options.callInterval = options.callInterval || 0;
    this.options.dbFilename = options.dbFilename || 'subspace.db';
    this.disableDatabase = options.disableDatabase;
    this.networkId = undefined;
    this.isWebsocketProvider = options.disableSubscriptions ? false : !!provider.on; // Stats

    this.latestBlockNumber = undefined;
    this.latestGasPrice = undefined;
    this.latestBlock = undefined;
    this.latest10Blocks = [];
    this.subjects = {};
    this.newBlocksSubscription = null;
    this.intervalTracker = null;
    this.callables = [];
  }

  _createClass(Subspace, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      return new _Promise(
      /*#__PURE__*/
      function () {
        var _ref = _asyncToGenerator(
        /*#__PURE__*/
        _regeneratorRuntime.mark(function _callee(resolve, reject) {
          var block, gasPrice, minBlock, i;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (_this2.disableDatabase === true) {
                    _this2._db = new NullDatabase("", _this2.events);
                  } else {
                    _this2._db = new Database(_this2.options.dbFilename, _this2.events);
                  }

                  _this2.eventSyncer = new EventSyncer(_this2.web3, _this2.events, _this2._db, _this2.isWebsocketProvider);
                  _this2.logSyncer = new LogSyncer(_this2.web3, _this2.events, _this2._db);

                  _this2.web3.net.getId().then(function (netId) {
                    _this2.networkId = netId;
                  });

                  _context.next = 6;
                  return _this2.web3.getBlock('latest');

                case 6:
                  block = _context.sent;
                  _context.next = 9;
                  return _this2.web3.getGasPrice();

                case 9:
                  gasPrice = _context.sent;

                  if (!(block.number !== 0)) {
                    _context.next = 16;
                    break;
                  }

                  minBlock = Math.max(0, block.number - 9);

                  for (i = minBlock; i < block.number; i++) {
                    _this2.latest10Blocks.push(_this2.web3.getBlock(i));
                  }

                  _context.next = 15;
                  return _Promise.all(_this2.latest10Blocks);

                case 15:
                  _this2.latest10Blocks = _context.sent;

                case 16:
                  // Initial stats
                  _this2.latestBlockNumber = block.number;
                  _this2.latestGasPrice = gasPrice;
                  _this2.latestBlock = block;

                  _this2.latest10Blocks.push(block);

                  if (_this2.isWebsocketProvider) {
                    _this2._initNewBlocksSubscription();
                  } else {
                    _this2.options.callInterval = _this2.options.callInterval || 1000;

                    _this2._initCallInterval();
                  }

                  resolve();

                case 22:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "contract",
    value: function contract(contractInstance) {
      var _this3 = this,
          _context3,
          _context5;

      if (!contractInstance) {
        throw new Error("please pass a contract instance to Subspace.contract()");
      }

      var address = contractInstance.options && contractInstance.options.address || contractInstance.address || contractInstance.deployedAddress;
      var abi = contractInstance.options && contractInstance.options.jsonInterface || contractInstance.abi || contractInstance.abiDefinition;
      var from = contractInstance.options && contractInstance.options.from || contractInstance.from || contractInstance.defaultAddress || this.web3.defaultAccount;
      var gas = contractInstance.options && contractInstance.options.gas || contractInstance.gas || contractInstance.gas || "800000";
      var SubspaceContract = new this.web3.Contract(abi, {
        from: from,
        gas: gas
      });
      SubspaceContract.options.address = address;
      SubspaceContract.options.from = from;

      if (!from) {
        _setTimeout(
        /*#__PURE__*/
        _asyncToGenerator(
        /*#__PURE__*/
        _regeneratorRuntime.mark(function _callee2() {
          var accounts;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _this3.web3.getAccounts();

                case 2:
                  accounts = _context2.sent;
                  SubspaceContract.options.from = accounts[0];

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        })), 100);
      }

      SubspaceContract.trackEvent = function (eventName, filterConditionsOrCb) {
        return _this3.trackEvent(SubspaceContract, eventName, filterConditionsOrCb);
      };

      _forEachInstanceProperty(_context3 = _Object$keys(SubspaceContract.events)).call(_context3, function (ev) {
        var _context4;

        if (!_findInstanceProperty(_context4 = SubspaceContract.options.jsonInterface).call(_context4, function (x) {
          return x.type === 'event' && x.name == ev;
        })) return;

        SubspaceContract.events[ev].track = function (filterConditionsOrCb) {
          return _this3.trackEvent(SubspaceContract, ev, filterConditionsOrCb);
        };
      });

      SubspaceContract.trackProperty = function (propName, methodArgs, callArgs) {
        return _this3.trackProperty(SubspaceContract, propName, methodArgs, callArgs);
      };

      _forEachInstanceProperty(_context5 = _Object$keys(SubspaceContract.methods)).call(_context5, function (methodName) {
        var oldFunc = SubspaceContract.methods[methodName];
        var _this = _this3;

        var newFunc = function newFunc() {
          var txObject = oldFunc.apply(null, arguments);

          txObject.track = function (callArgs) {
            return _this.trackProperty(SubspaceContract, methodName, txObject.arguments, callArgs);
          };

          return txObject;
        };

        SubspaceContract.methods[methodName] = newFunc;
      });

      SubspaceContract.trackBalance = function (erc20Address) {
        return _this3.trackBalance(SubspaceContract.options.address, erc20Address);
      };

      return SubspaceContract;
    } // TODO: get contract abi/address instead

  }, {
    key: "trackEvent",
    value: function trackEvent(contractInstance, eventName, filterConditions) {
      var subjectHash = hash({
        address: contractInstance.options.address,
        networkId: this.networkId,
        eventName: eventName,
        filterConditions: filterConditions
      });
      if (this.subjects[subjectHash]) return this.subjects[subjectHash];
      var deleteFrom = this.latestBlockNumber - this.options.refreshLastNBlocks;
      var returnSub = this.eventSyncer.track(contractInstance, eventName, filterConditions, deleteFrom, this.networkId);

      returnSub.map = function (prop) {
        return returnSub.pipe(map(function (x) {
          if (typeof prop === "string") {
            return x[prop];
          }

          if (_Array$isArray(prop)) {
            var newValues = {};

            _forEachInstanceProperty(prop).call(prop, function (p) {
              newValues[p] = x[p];
            });

            return newValues;
          }
        }));
      };

      this.subjects[subjectHash] = returnSub;
      return returnSub;
    }
  }, {
    key: "clearDB",
    value: function clearDB(collection) {
      if (collection) {// TODO: delete specific collection
      } else {// TODO: delete everything
        }
    }
  }, {
    key: "trackLogs",
    value: function trackLogs(options, inputsABI) {
      if (!this.isWebsocketProvider) console.warn("This method only works with websockets");
      var subjectHash = hash({
        inputsABI: inputsABI,
        options: options
      });
      if (this.subjects[subjectHash]) return this.subjects[subjectHash];
      this.subjects[subjectHash] = this.logSyncer.track(options, inputsABI, this.latestBlockNumber - this.options.refreshLastNBlocks, this.networkId);
      return this.subjects[subjectHash];
    }
  }, {
    key: "_initNewBlocksSubscription",
    value: function _initNewBlocksSubscription() {
      var _this4 = this;

      if (this.newBlocksSubscription != null || this.options.callInterval !== 0) return;
      this.newBlocksSubscription = this.web3.subscribe('newBlockHeaders', function (err, result) {
        var _context6;

        if (err) {
          console.error(err);
          return;
        }

        _forEachInstanceProperty(_context6 = _this4.callables).call(_context6, function (fn) {
          fn();
        });
      });
    }
  }, {
    key: "_initCallInterval",
    value: function _initCallInterval() {
      var _this5 = this;

      if (this.intervalTracker != null || this.options.callInterval === 0) return;
      this.intervalTracker = _setInterval(function () {
        var _context7;

        _forEachInstanceProperty(_context7 = _this5.callables).call(_context7, function (fn) {
          fn();
        });
      }, this.options.callInterval);
    }
  }, {
    key: "trackProperty",
    value: function trackProperty(contractInstance, propName) {
      var methodArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var callArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var subjectHash = hash({
        address: contractInstance.options.address,
        networkId: this.networkId,
        propName: propName,
        methodArgs: methodArgs,
        callArgs: callArgs
      });
      if (this.subjects[subjectHash]) return this.subjects[subjectHash];
      var subject = new Subject();

      if (!_Array$isArray(methodArgs)) {
        methodArgs = [methodArgs];
      }

      var method = contractInstance.methods[propName].apply(contractInstance.methods[propName], methodArgs);

      var callContractMethod = function callContractMethod() {
        method.call.apply(method.call, [callArgs, function (err, result) {
          if (err) {
            subject.error(err);
            return;
          }

          subject.next(result);
        }]);
      };

      callContractMethod();
      this.callables.push(callContractMethod);
      var returnSub = subject.pipe(distinctUntilChanged(function (a, b) {
        return equal(a, b);
      }));

      returnSub.map = function (prop) {
        return returnSub.pipe(map(function (x) {
          if (typeof prop === "string") {
            return x[prop];
          }

          if (_Array$isArray(prop)) {
            var newValues = {};

            _forEachInstanceProperty(prop).call(prop, function (p) {
              newValues[p] = x[p];
            });

            return newValues;
          }
        }));
      };

      this.subjects[subjectHash] = returnSub;
      return returnSub;
    }
  }, {
    key: "_addDistinctCallable",
    value: function _addDistinctCallable(trackAttribute, cbBuilder, subject) {
      var subjectArg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      if (this.subjects[trackAttribute]) return this.subjects[trackAttribute];
      var sub = new subject(subjectArg);
      var cb = cbBuilder(sub);
      cb();
      this.callables.push(cb);
      this.subjects[trackAttribute] = sub.pipe(distinctUntilChanged(function (a, b) {
        return equal(a, b);
      }));
      return this.subjects[trackAttribute];
    }
  }, {
    key: "trackBlock",
    value: function trackBlock() {
      var _this6 = this;

      var blockCB = function blockCB(subject) {
        return function () {
          _this6.web3.getBlock('latest').then(function (block) {
            if (_this6.latest10Blocks[_this6.latest10Blocks.length - 1].number === block.number) return;

            _this6.latest10Blocks.push(block);

            if (_this6.latest10Blocks.length > 10) {
              _this6.latest10Blocks.shift();
            }

            subject.next(block);
          }).catch(function (error) {
            return subject.error(error);
          });
        };
      };

      return this._addDistinctCallable('blockObservable', blockCB, BehaviorSubject, this.latestBlock);
    }
  }, {
    key: "trackBlockNumber",
    value: function trackBlockNumber() {
      var _this7 = this;

      var blockNumberCB = function blockNumberCB(subject) {
        return function () {
          _this7.web3.getBlockNumber().then(function (blockNumber) {
            return subject.next(blockNumber);
          }).catch(function (error) {
            return subject.error(error);
          });
        };
      };

      return this._addDistinctCallable('blockNumberObservable', blockNumberCB, BehaviorSubject, this.latestBlockNumber);
    }
  }, {
    key: "trackGasPrice",
    value: function trackGasPrice() {
      var _this8 = this;

      var gasPriceCB = function gasPriceCB(subject) {
        return function () {
          _this8.web3.getGasPrice().then(function (gasPrice) {
            return subject.next(gasPrice);
          }).catch(function (error) {
            return subject.error(error);
          });
        };
      };

      return this._addDistinctCallable('gasPriceObservable', gasPriceCB, BehaviorSubject, this.latestGasPrice);
    }
  }, {
    key: "trackAverageBlocktime",
    value: function trackAverageBlocktime() {
      var _this9 = this;

      this.trackBlock();

      var avgTimeCB = function avgTimeCB(subject) {
        return function () {
          var times = [];

          for (var i = 1; i < _this9.latest10Blocks.length; i++) {
            var time = _this9.latest10Blocks[i].timestamp - _this9.latest10Blocks[i - 1].timestamp;
            times.push(time);
          }

          var average = times.length ? Math.round(_reduceInstanceProperty(times).call(times, function (a, b) {
            return a + b;
          }) / times.length) * 1000 : 0;
          subject.next(average);
        };
      };

      return this._addDistinctCallable('blockTimeObservable', avgTimeCB, BehaviorSubject, 123456);
    }
  }, {
    key: "trackBalance",
    value: function trackBalance(address, erc20Address) {
      var _this10 = this;

      var sub = new ReplaySubject();
      if (!isAddress(address)) throw "invalid address";
      if (erc20Address && !isAddress(erc20Address)) throw "invalid ERC20 contract address";
      var callFn;

      if (!erc20Address) {
        callFn = function callFn() {
          var fn = _this10.web3.getBalance;
          fn.apply(fn, [address, function (err, balance) {
            if (err) {
              sub.error(err);
              return;
            }

            sub.next(balance);
          }]);
        };
      } else {
        callFn = function callFn() {
          var fn = _this10.web3.call; //  balanceOf

          var data = "0x70a08231" + "000000000000000000000000" + stripHexPrefix(address);
          fn.apply(fn, [{
            to: erc20Address,
            data: data
          }, function (err, result) {
            if (err) {
              sub.error(err);
              return;
            }

            sub.next(hexToDec(result));
          }]);
        };
      } // FIX ME: has issues immediatly getting the value
      // this.web3.getBlock('latest').then(block => {


      _setTimeout(function () {
        callFn();
      }, 500); // });


      this.callables.push(callFn);
      return sub.pipe(distinctUntilChanged(function (a, b) {
        return equal(a, b);
      }));
    }
  }, {
    key: "close",
    value: function close() {
      clearInterval(this.intervalTracker);
      if (this.newBlocksSubscription) this.newBlocksSubscription.unsubscribe();
      this.eventSyncer.close();
      this.intervalTracker = null;
      this.callables = [];
    }
  }]);

  return Subspace;
}();

export { Subspace as default };
//# sourceMappingURL=subspace.js.map