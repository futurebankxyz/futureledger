import "core-js/modules/es.object.to-string";
import "core-js/modules/es.regexp.to-string";
import _fillInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/fill";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import "regenerator-runtime/runtime";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import { sleep } from './utils';

var HttpEventScanner =
/*#__PURE__*/
function () {
  function HttpEventScanner(web3) {
    _classCallCheck(this, HttpEventScanner);

    this.pollExecution = [];
    this.web3 = web3;
  }

  _createClass(HttpEventScanner, [{
    key: "poll",
    value: function () {
      var _poll = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(execId, fn, timeout) {
        var shouldStop;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return fn();

              case 2:
                shouldStop = _context.sent;

                if (!(!this.pollExecution[execId] || shouldStop)) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return");

              case 5:
                if (!timeout) {
                  _context.next = 8;
                  break;
                }

                _context.next = 8;
                return sleep(timeout * 1000);

              case 8:
                _context.next = 10;
                return this.poll(execId, fn, timeout);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function poll(_x, _x2, _x3) {
        return _poll.apply(this, arguments);
      }

      return poll;
    }()
  }, {
    key: "scan",
    value: function () {
      var _scan = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4(serveDBEvents, getPastEvents, lastCachedBlock, filterConditions) {
        var _this = this;

        var execId, maxBlockRange, lastBlockNumberAtLoad, toBlockFilter, toBlockInPast, dbLimit;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                execId = this.pollExecution.push(true) - 1;
                maxBlockRange = 500000; // TODO: extract to config

                _context4.next = 4;
                return this.web3.getBlockNumber();

              case 4:
                lastBlockNumberAtLoad = _context4.sent;
                // If there's a toBlock with a number
                toBlockFilter = 0;

                if (filterConditions.toBlock && filterConditions.toBlock !== 'latest') {
                  toBlockFilter = filterConditions.toBlock;
                }

                toBlockInPast = toBlockFilter && toBlockFilter < lastBlockNumberAtLoad; // Determine if data already exists and return it.

                dbLimit = toBlockFilter > 0 ? Math.min(toBlockFilter, lastCachedBlock) : lastCachedBlock;

                if (lastCachedBlock > 0 && filterConditions.fromBlock >= 0) {
                  serveDBEvents(filterConditions, dbLimit);
                  lastCachedBlock = lastCachedBlock + 1;
                }

                lastCachedBlock = Math.max(lastCachedBlock, filterConditions.fromBlock || 0); // Get old events and store them in db

                _context4.next = 13;
                return this.poll(execId,
                /*#__PURE__*/
                _asyncToGenerator(
                /*#__PURE__*/
                _regeneratorRuntime.mark(function _callee2() {
                  var maxBlock, toBlock, toBlockLimit;
                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.prev = 0;
                          maxBlock = Math.min(lastCachedBlock + maxBlockRange, lastBlockNumberAtLoad);
                          toBlock = toBlockInPast ? Math.min(maxBlock, toBlockFilter) : maxBlock;
                          _context2.t0 = Math;
                          _context2.next = 6;
                          return _this.web3.getBlockNumber();

                        case 6:
                          _context2.t1 = _context2.sent;
                          _context2.t2 = toBlock;
                          toBlockLimit = _context2.t0.min.call(_context2.t0, _context2.t1, _context2.t2);

                          if (!(toBlockLimit >= lastCachedBlock)) {
                            _context2.next = 13;
                            break;
                          }

                          _context2.next = 12;
                          return getPastEvents(lastCachedBlock, toBlockLimit, toBlockInPast ? toBlockFilter : null);

                        case 12:
                          lastCachedBlock = toBlockLimit + 1;

                        case 13:
                          _context2.next = 18;
                          break;

                        case 15:
                          _context2.prev = 15;
                          _context2.t3 = _context2["catch"](0);
                          console.log(_context2.t3.toString());

                        case 18:
                          return _context2.abrupt("return", toBlockInPast && lastCachedBlock >= (toBlockFilter || 0) || lastCachedBlock > Math.max(lastBlockNumberAtLoad, toBlockInPast ? toBlockFilter || 0 : 0));

                        case 19:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, null, [[0, 15]]);
                })));

              case 13:
                if (!toBlockInPast) {
                  _context4.next = 15;
                  break;
                }

                return _context4.abrupt("return");

              case 15:
                _context4.next = 17;
                return this.poll(execId,
                /*#__PURE__*/
                _asyncToGenerator(
                /*#__PURE__*/
                _regeneratorRuntime.mark(function _callee3() {
                  var toBlockLimit;
                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.prev = 0;
                          _context3.next = 3;
                          return _this.web3.getBlockNumber();

                        case 3:
                          toBlockLimit = _context3.sent;

                          if (!(toBlockLimit >= lastCachedBlock)) {
                            _context3.next = 8;
                            break;
                          }

                          _context3.next = 7;
                          return getPastEvents(lastCachedBlock, toBlockLimit, toBlockFilter || 0);

                        case 7:
                          lastCachedBlock = toBlockLimit + 1;

                        case 8:
                          _context3.next = 13;
                          break;

                        case 10:
                          _context3.prev = 10;
                          _context3.t0 = _context3["catch"](0);
                          console.log(_context3.t0.toString());

                        case 13:
                          return _context3.abrupt("return", filterConditions.toBlock !== 'latest' && lastCachedBlock > Math.max(lastBlockNumberAtLoad, toBlockFilter || 0));

                        case 14:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, null, [[0, 10]]);
                })), 1);

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function scan(_x4, _x5, _x6, _x7) {
        return _scan.apply(this, arguments);
      }

      return scan;
    }()
  }, {
    key: "close",
    value: function close() {
      var _context5;

      this.pollExecution = _fillInstanceProperty(_context5 = Array(this.pollExecution.length)).call(_context5, false);
    }
  }]);

  return HttpEventScanner;
}();

export default HttpEventScanner;
//# sourceMappingURL=httpEventScanner.js.map