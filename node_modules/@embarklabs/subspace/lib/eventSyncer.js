import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import "regenerator-runtime/runtime";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context5; _forEachInstanceProperty(_context5 = ownKeys(Object(source), true)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { var _context6; _forEachInstanceProperty(_context6 = ownKeys(Object(source))).call(_context6, function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { fromEvent, ReplaySubject } from 'rxjs';
import hash from 'object-hash';
import HttpEventScanner from './httpEventScanner';
import WsEventScanner from './wsEventScanner';

var EventSyncer =
/*#__PURE__*/
function () {
  function EventSyncer(web3, _events, db, isWebsocketProvider) {
    var _this = this;

    _classCallCheck(this, EventSyncer);

    _defineProperty(this, "getPastEvents", function (eventKey, contractInstance, eventName, filters) {
      return (
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee(fromBlock, toBlock, hardLimit) {
            var events, cb;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return contractInstance.getPastEvents(eventName, _objectSpread({}, filters, {
                      fromBlock: fromBlock,
                      toBlock: toBlock
                    }));

                  case 2:
                    events = _context.sent;
                    cb = _this.callbackFactory(filters, eventKey);

                    _forEachInstanceProperty(events).call(events, function (ev) {
                      return cb(null, ev);
                    });

                    if (hardLimit && toBlock === hardLimit) {
                      // Complete the observable
                      _this.events.emit(eventKey);
                    }

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }()
      );
    });

    _defineProperty(this, "serveDBEvents", function (eventKey) {
      return function (filters, toBlock) {
        var _context2;

        var fromBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var cb = _this.callbackFactory(filters, eventKey);

        var storedEvents = _filterInstanceProperty(_context2 = _this.db.getEventsFor(eventKey)).call(_context2, function (x) {
          return x.blockNumber >= (fromBlock || filters.fromBlock) && x.blockNumber <= toBlock;
        });

        _forEachInstanceProperty(storedEvents).call(storedEvents, function (ev) {
          cb(null, ev);
        });
      };
    });

    _defineProperty(this, "subscribeToEvent", function (eventKey, contractInstance, eventName) {
      return function (subscriptions, filters) {
        var cb = _this.callbackFactory(filters, eventKey);

        var s = contractInstance.events[eventName](filters, cb);
        subscriptions.push(s);
        return s;
      };
    });

    _defineProperty(this, "callbackFactory", function (filterConditions, eventKey) {
      return function (err, ev) {
        if (err) {
          console.error(err);
          return;
        }

        if (filterConditions) {
          var propsToFilter = [];

          for (var prop in _filterInstanceProperty(filterConditions)) {
            var _context3;

            if (_indexOfInstanceProperty(_context3 = _Object$keys(ev.returnValues)).call(_context3, prop) >= 0) {
              propsToFilter.push(prop);
            }
          }

          for (var _i = 0, _propsToFilter = propsToFilter; _i < _propsToFilter.length; _i++) {
            var _prop = _propsToFilter[_i];
            if (_filterInstanceProperty(filterConditions)[_prop] !== ev.returnValues[_prop]) return;
          }
        }

        _this.events.emit(eventKey, ev);
      };
    });

    this.events = _events;
    this.web3 = web3;
    this.db = db;
    this.isWebsocketProvider = isWebsocketProvider;
    this.eventScanner = isWebsocketProvider ? new WsEventScanner(web3) : new HttpEventScanner(web3);
  }

  _createClass(EventSyncer, [{
    key: "track",
    value: function track(contractInstance, eventName, filters, gteBlockNum, networkId) {
      var _this2 = this;

      var eventKey = hash(_Object$assign({
        address: contractInstance.options.address,
        networkId: networkId
      }, filters || {}));
      this.db.deleteNewestBlocks(eventKey, gteBlockNum);

      var filterConditions = _Object$assign({
        fromBlock: 0,
        toBlock: "latest"
      }, filters || {});

      var lastKnownBlock = this.db.getLastKnownEvent(eventKey);
      var firstKnownBlock = this.db.getFirstKnownEvent(eventKey);
      var sub = new ReplaySubject();
      var contractObserver = fromEvent(this.events, eventKey);
      contractObserver.subscribe(function (e) {
        if (!e) {
          sub.complete();
          return;
        }

        var id = hash({
          eventName: eventName,
          blockNumber: e.blockNumber,
          transactionIndex: e.transactionIndex,
          logIndex: e.logIndex
        }); // TODO: would be nice if this was smart enough to understand the type of returnValues and do the needed conversions

        var eventData = {
          id: id,
          returnValues: _objectSpread({}, e.returnValues),
          blockNumber: e.blockNumber,
          transactionIndex: e.transactionIndex,
          logIndex: e.logIndex,
          removed: e.removed
        }; // TODO: test reorgs

        sub.next(_objectSpread({
          blockNumber: e.blockNumber
        }, e.returnValues));

        if (e.removed) {
          _this2.db.deleteEvent(eventKey, id);

          return;
        }

        if (_this2.db.eventExists(eventKey, eventData.id)) return;

        _this2.db.recordEvent(eventKey, eventData);

        _this2.events.emit("updateDB");
      });
      var fnDBEvents = this.serveDBEvents(eventKey);
      var fnPastEvents = this.getPastEvents(eventKey, contractInstance, eventName, filters);

      if (this.isWebsocketProvider) {
        var fnSubscribe = this.subscribeToEvent(eventKey, contractInstance, eventName);
        var eth_subscribe = this.eventScanner.scan(fnDBEvents, fnPastEvents, fnSubscribe, firstKnownBlock, lastKnownBlock, filterConditions);
        var og_subscribe = sub.subscribe;

        sub.subscribe =
        /*#__PURE__*/
        function () {
          var _ref2 = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee2(next, error, complete) {
            var s;
            return _regeneratorRuntime.wrap(function _callee2$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    s = og_subscribe.apply(sub, [next, error, complete]);
                    s.add(function () {
                      // Removing web3js subscription when rxJS unsubscribe is executed
                      eth_subscribe.then(function (susc) {
                        if (susc) {
                          susc.unsubscribe();
                        }
                      });
                    });
                    return _context4.abrupt("return", s);

                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee2);
          }));

          return function (_x4, _x5, _x6) {
            return _ref2.apply(this, arguments);
          };
        }();
      } else {
        this.eventScanner.scan(fnDBEvents, fnPastEvents, lastKnownBlock, filterConditions);
      }

      return sub;
    }
  }, {
    key: "close",
    value: function close() {
      this.eventScanner.close();
    }
  }]);

  return EventSyncer;
}();

export default EventSyncer;
//# sourceMappingURL=eventSyncer.js.map