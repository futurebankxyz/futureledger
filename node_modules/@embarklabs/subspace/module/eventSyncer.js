import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";
import { fromEvent, ReplaySubject } from 'rxjs';
import hash from 'object-hash';
import HttpEventScanner from './httpEventScanner';
import WsEventScanner from './wsEventScanner';

class EventSyncer {
  constructor(web3, _events, db, isWebsocketProvider) {
    _defineProperty(this, "getPastEvents", (eventKey, contractInstance, eventName, filters) => async (fromBlock, toBlock, hardLimit) => {
      let events = await contractInstance.getPastEvents(eventName, { ...filters,
        fromBlock,
        toBlock
      });
      const cb = this.callbackFactory(filters, eventKey);

      _forEachInstanceProperty(events).call(events, ev => cb(null, ev));

      if (hardLimit && toBlock === hardLimit) {
        // Complete the observable
        this.events.emit(eventKey);
      }
    });

    _defineProperty(this, "serveDBEvents", eventKey => (filters, toBlock, fromBlock = null) => {
      var _context;

      const cb = this.callbackFactory(filters, eventKey);

      const storedEvents = _filterInstanceProperty(_context = this.db.getEventsFor(eventKey)).call(_context, x => x.blockNumber >= (fromBlock || filters.fromBlock) && x.blockNumber <= toBlock);

      _forEachInstanceProperty(storedEvents).call(storedEvents, ev => {
        cb(null, ev);
      });
    });

    _defineProperty(this, "subscribeToEvent", (eventKey, contractInstance, eventName) => (subscriptions, filters) => {
      const cb = this.callbackFactory(filters, eventKey);
      const s = contractInstance.events[eventName](filters, cb);
      subscriptions.push(s);
      return s;
    });

    _defineProperty(this, "callbackFactory", (filterConditions, eventKey) => (err, ev) => {
      if (err) {
        console.error(err);
        return;
      }

      if (filterConditions) {
        let propsToFilter = [];

        for (let prop in _filterInstanceProperty(filterConditions)) {
          var _context2;

          if (_indexOfInstanceProperty(_context2 = _Object$keys(ev.returnValues)).call(_context2, prop) >= 0) {
            propsToFilter.push(prop);
          }
        }

        for (let prop of propsToFilter) {
          if (_filterInstanceProperty(filterConditions)[prop] !== ev.returnValues[prop]) return;
        }
      }

      this.events.emit(eventKey, ev);
    });

    this.events = _events;
    this.web3 = web3;
    this.db = db;
    this.isWebsocketProvider = isWebsocketProvider;
    this.eventScanner = isWebsocketProvider ? new WsEventScanner(web3) : new HttpEventScanner(web3);
  }

  track(contractInstance, eventName, filters, gteBlockNum, networkId) {
    const eventKey = hash(_Object$assign({
      address: contractInstance.options.address,
      networkId
    }, filters || {}));
    this.db.deleteNewestBlocks(eventKey, gteBlockNum);

    let filterConditions = _Object$assign({
      fromBlock: 0,
      toBlock: "latest"
    }, filters || {});

    let lastKnownBlock = this.db.getLastKnownEvent(eventKey);
    let firstKnownBlock = this.db.getFirstKnownEvent(eventKey);
    let sub = new ReplaySubject();
    let contractObserver = fromEvent(this.events, eventKey);
    contractObserver.subscribe(e => {
      if (!e) {
        sub.complete();
        return;
      }

      const id = hash({
        eventName,
        blockNumber: e.blockNumber,
        transactionIndex: e.transactionIndex,
        logIndex: e.logIndex
      }); // TODO: would be nice if this was smart enough to understand the type of returnValues and do the needed conversions

      const eventData = {
        id,
        returnValues: { ...e.returnValues
        },
        blockNumber: e.blockNumber,
        transactionIndex: e.transactionIndex,
        logIndex: e.logIndex,
        removed: e.removed
      }; // TODO: test reorgs

      sub.next({
        blockNumber: e.blockNumber,
        ...e.returnValues
      });

      if (e.removed) {
        this.db.deleteEvent(eventKey, id);
        return;
      }

      if (this.db.eventExists(eventKey, eventData.id)) return;
      this.db.recordEvent(eventKey, eventData);
      this.events.emit("updateDB");
    });
    const fnDBEvents = this.serveDBEvents(eventKey);
    const fnPastEvents = this.getPastEvents(eventKey, contractInstance, eventName, filters);

    if (this.isWebsocketProvider) {
      const fnSubscribe = this.subscribeToEvent(eventKey, contractInstance, eventName);
      const eth_subscribe = this.eventScanner.scan(fnDBEvents, fnPastEvents, fnSubscribe, firstKnownBlock, lastKnownBlock, filterConditions);
      const og_subscribe = sub.subscribe;

      sub.subscribe = async (next, error, complete) => {
        const s = og_subscribe.apply(sub, [next, error, complete]);
        s.add(() => {
          // Removing web3js subscription when rxJS unsubscribe is executed
          eth_subscribe.then(susc => {
            if (susc) {
              susc.unsubscribe();
            }
          });
        });
        return s;
      };
    } else {
      this.eventScanner.scan(fnDBEvents, fnPastEvents, lastKnownBlock, filterConditions);
    }

    return sub;
  }

  close() {
    this.eventScanner.close();
  }

}

export default EventSyncer;
//# sourceMappingURL=eventSyncer.js.map