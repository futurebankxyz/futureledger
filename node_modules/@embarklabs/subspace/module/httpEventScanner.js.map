{"version":3,"sources":["../src/httpEventScanner.js"],"names":["sleep","HttpEventScanner","constructor","web3","pollExecution","poll","execId","fn","timeout","shouldStop","scan","serveDBEvents","getPastEvents","lastCachedBlock","filterConditions","push","maxBlockRange","lastBlockNumberAtLoad","getBlockNumber","toBlockFilter","toBlock","toBlockInPast","dbLimit","Math","min","fromBlock","max","maxBlock","toBlockLimit","e","console","log","toString","close","Array","length"],"mappings":"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","sourcesContent":["import {sleep} from './utils'\n\nclass HttpEventScanner {\n  constructor(web3){\n    this.pollExecution = [];\n    this.web3 = web3;\n  }\n\n  async poll(execId, fn, timeout){\n    const shouldStop = await fn();\n    if(!this.pollExecution[execId] || shouldStop) return;\n    if(timeout) await sleep(timeout * 1000);\n    await this.poll(execId, fn, timeout);\n  }\n\n  async scan(serveDBEvents, getPastEvents, lastCachedBlock, filterConditions) {\n    const execId = this.pollExecution.push(true) - 1;\n    const maxBlockRange = 500000; // TODO: extract to config\n    const lastBlockNumberAtLoad = await this.web3.getBlockNumber();\n\n    // If there's a toBlock with a number\n    let toBlockFilter = 0;\n    if(filterConditions.toBlock && filterConditions.toBlock !== 'latest' ){\n      toBlockFilter = filterConditions.toBlock;\n    }\n    const toBlockInPast =  toBlockFilter && toBlockFilter < lastBlockNumberAtLoad;\n\n    // Determine if data already exists and return it.\n    let dbLimit = toBlockFilter > 0 ? Math.min(toBlockFilter, lastCachedBlock) : lastCachedBlock;\n    if(lastCachedBlock > 0 && filterConditions.fromBlock >= 0){\n      serveDBEvents(filterConditions, dbLimit);\n      lastCachedBlock = lastCachedBlock + 1;\n    }\n    \n    lastCachedBlock = Math.max(lastCachedBlock, filterConditions.fromBlock||0);\n\n    // Get old events and store them in db\n    await this.poll(execId, async () => {\n      try {\n        const maxBlock = Math.min(lastCachedBlock + maxBlockRange, lastBlockNumberAtLoad);\n        const toBlock = toBlockInPast ? Math.min(maxBlock, toBlockFilter) : maxBlock;\n        const toBlockLimit = Math.min(await this.web3.getBlockNumber(), toBlock);  \n\n        if(toBlockLimit >= lastCachedBlock) {  \n          await getPastEvents(lastCachedBlock, toBlockLimit, toBlockInPast ? toBlockFilter : null);  \n          lastCachedBlock = toBlockLimit + 1;  \n        }\n      } catch (e) {  \n        console.log(e.toString());  \n      } \n\n      // Should exit?\n      return (toBlockInPast && lastCachedBlock >= (toBlockFilter || 0)) || (lastCachedBlock > Math.max(lastBlockNumberAtLoad, toBlockInPast ? toBlockFilter || 0 : 0));\n     });\n\n    if(toBlockInPast) return;\n\n    // Get new data, with a timeout between requests\n    await this.poll(execId, async () => {\n      try {\n        let toBlockLimit = await this.web3.getBlockNumber()\n        if(toBlockLimit >= lastCachedBlock) {  \n          await getPastEvents(lastCachedBlock, toBlockLimit, toBlockFilter || 0);  \n          lastCachedBlock = toBlockLimit + 1;  \n        }\n      } catch (e) {  \n        console.log(e.toString());  \n      } \n\n      // Should exit?\n      return filterConditions.toBlock !== 'latest' && lastCachedBlock > Math.max(lastBlockNumberAtLoad, toBlockFilter || 0);\n    }, 1);\n    \n  }\n\n  close(){\n    this.pollExecution = Array(this.pollExecution.length).fill(false);\n  }\n}\n\nexport default HttpEventScanner;\n"],"file":"httpEventScanner.js"}