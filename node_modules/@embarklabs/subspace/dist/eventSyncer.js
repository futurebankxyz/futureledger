"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _rxjs = require("rxjs");

var _objectHash = _interopRequireDefault(require("object-hash"));

var _httpEventScanner = _interopRequireDefault(require("./httpEventScanner"));

var _wsEventScanner = _interopRequireDefault(require("./wsEventScanner"));

class EventSyncer {
  constructor(web3, _events, db, isWebsocketProvider) {
    (0, _defineProperty2.default)(this, "getPastEvents", (eventKey, contractInstance, eventName, filters) => async (fromBlock, toBlock, hardLimit) => {
      let events = await contractInstance.getPastEvents(eventName, { ...filters,
        fromBlock,
        toBlock
      });
      const cb = this.callbackFactory(filters, eventKey);
      (0, _forEach.default)(events).call(events, ev => cb(null, ev));

      if (hardLimit && toBlock === hardLimit) {
        // Complete the observable
        this.events.emit(eventKey);
      }
    });
    (0, _defineProperty2.default)(this, "serveDBEvents", eventKey => (filters, toBlock, fromBlock = null) => {
      var _context;

      const cb = this.callbackFactory(filters, eventKey);
      const storedEvents = (0, _filter.default)(_context = this.db.getEventsFor(eventKey)).call(_context, x => x.blockNumber >= (fromBlock || filters.fromBlock) && x.blockNumber <= toBlock);
      (0, _forEach.default)(storedEvents).call(storedEvents, ev => {
        cb(null, ev);
      });
    });
    (0, _defineProperty2.default)(this, "subscribeToEvent", (eventKey, contractInstance, eventName) => (subscriptions, filters) => {
      const cb = this.callbackFactory(filters, eventKey);
      const s = contractInstance.events[eventName](filters, cb);
      subscriptions.push(s);
      return s;
    });
    (0, _defineProperty2.default)(this, "callbackFactory", (filterConditions, eventKey) => (err, ev) => {
      if (err) {
        console.error(err);
        return;
      }

      if (filterConditions) {
        let propsToFilter = [];

        for (let prop in (0, _filter.default)(filterConditions)) {
          var _context2;

          if ((0, _indexOf.default)(_context2 = (0, _keys.default)(ev.returnValues)).call(_context2, prop) >= 0) {
            propsToFilter.push(prop);
          }
        }

        for (let prop of propsToFilter) {
          if ((0, _filter.default)(filterConditions)[prop] !== ev.returnValues[prop]) return;
        }
      }

      this.events.emit(eventKey, ev);
    });
    this.events = _events;
    this.web3 = web3;
    this.db = db;
    this.isWebsocketProvider = isWebsocketProvider;
    this.eventScanner = isWebsocketProvider ? new _wsEventScanner.default(web3) : new _httpEventScanner.default(web3);
  }

  track(contractInstance, eventName, filters, gteBlockNum, networkId) {
    const eventKey = (0, _objectHash.default)((0, _assign.default)({
      address: contractInstance.options.address,
      networkId
    }, filters || {}));
    this.db.deleteNewestBlocks(eventKey, gteBlockNum);
    let filterConditions = (0, _assign.default)({
      fromBlock: 0,
      toBlock: "latest"
    }, filters || {});
    let lastKnownBlock = this.db.getLastKnownEvent(eventKey);
    let firstKnownBlock = this.db.getFirstKnownEvent(eventKey);
    let sub = new _rxjs.ReplaySubject();
    let contractObserver = (0, _rxjs.fromEvent)(this.events, eventKey);
    contractObserver.subscribe(e => {
      if (!e) {
        sub.complete();
        return;
      }

      const id = (0, _objectHash.default)({
        eventName,
        blockNumber: e.blockNumber,
        transactionIndex: e.transactionIndex,
        logIndex: e.logIndex
      }); // TODO: would be nice if this was smart enough to understand the type of returnValues and do the needed conversions

      const eventData = {
        id,
        returnValues: { ...e.returnValues
        },
        blockNumber: e.blockNumber,
        transactionIndex: e.transactionIndex,
        logIndex: e.logIndex,
        removed: e.removed
      }; // TODO: test reorgs

      sub.next({
        blockNumber: e.blockNumber,
        ...e.returnValues
      });

      if (e.removed) {
        this.db.deleteEvent(eventKey, id);
        return;
      }

      if (this.db.eventExists(eventKey, eventData.id)) return;
      this.db.recordEvent(eventKey, eventData);
      this.events.emit("updateDB");
    });
    const fnDBEvents = this.serveDBEvents(eventKey);
    const fnPastEvents = this.getPastEvents(eventKey, contractInstance, eventName, filters);

    if (this.isWebsocketProvider) {
      const fnSubscribe = this.subscribeToEvent(eventKey, contractInstance, eventName);
      const eth_subscribe = this.eventScanner.scan(fnDBEvents, fnPastEvents, fnSubscribe, firstKnownBlock, lastKnownBlock, filterConditions);
      const og_subscribe = sub.subscribe;

      sub.subscribe = async (next, error, complete) => {
        const s = og_subscribe.apply(sub, [next, error, complete]);
        s.add(() => {
          // Removing web3js subscription when rxJS unsubscribe is executed
          eth_subscribe.then(susc => {
            if (susc) {
              susc.unsubscribe();
            }
          });
        });
        return s;
      };
    } else {
      this.eventScanner.scan(fnDBEvents, fnPastEvents, lastKnownBlock, filterConditions);
    }

    return sub;
  }

  close() {
    this.eventScanner.close();
  }

}

var _default = EventSyncer;
exports.default = _default;
//# sourceMappingURL=eventSyncer.js.map