"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _rxjs = require("rxjs");

var _lokijs = _interopRequireDefault(require("lokijs"));

const getENV = function () {
  if (typeof global !== 'undefined' && (global.android || global.NSObject)) {
    // If no adapter assume nativescript which needs adapter to be passed manually
    return 'NATIVESCRIPT'; //nativescript
  }

  if (typeof window === 'undefined') {
    return 'NODEJS';
  } // TODO: LokiJS determines it's running in a browser if process is undefined, 
  // yet we need webpack shim for process in a different package.
  // this code ignores is the same getENV from loki except for the check for node webkit


  if (typeof document !== 'undefined') {
    var _context, _context2;

    if ((0, _indexOf.default)(_context = document.URL).call(_context, 'http://') === -1 && (0, _indexOf.default)(_context2 = document.URL).call(_context2, 'https://') === -1) {
      return 'CORDOVA';
    }

    return 'BROWSER';
  }

  return 'CORDOVA';
};

class Database {
  constructor(dbFilename, events, cb) {
    this.db = new _lokijs.default(dbFilename, {
      autoload: true,
      autoloadCallback: () => {
        this.databaseInitialize();
      },
      autosave: true,
      env: getENV(),
      autosaveInterval: 2000
    });
    this.events = events;
  }

  databaseInitialize(cb) {
    let dbChanges = (0, _rxjs.fromEvent)(this.events, "updateDB");
    dbChanges.subscribe(() => {
      this.db.saveDatabase();
    });
  }

  getLastKnownEvent(eventKey) {
    const collection = this.db.getCollection(eventKey);

    if (collection && collection.count()) {
      return collection.max('blockNumber');
    } else {
      this.db.addCollection(eventKey);
    }

    return 0;
  }

  getFirstKnownEvent(eventKey) {
    const collection = this.db.getCollection(eventKey);

    if (collection && collection.count()) {
      return collection.min('blockNumber');
    } else {
      this.db.addCollection(eventKey);
    }

    return 0;
  }

  getEventsFor(eventKey) {
    let children = this.db.getCollection(eventKey);
    return (0, _find.default)(children).call(children);
  }

  eventExists(eventKey, eventId) {
    let collection = this.db.getCollection(eventKey);

    if (!collection) {
      this.db.addCollection(eventKey);
      return false;
    }

    return (0, _find.default)(collection).call(collection, {
      'id': eventId
    }).length > 0;
  }

  recordEvent(eventKey, values) {
    let children = this.db.getCollection(eventKey);
    children.insert(values);
  }

  deleteEvent(eventKey, eventId) {
    var _context3;

    const collection = this.db.getCollection(eventKey);
    if (collection) (0, _find.default)(_context3 = collection.chain()).call(_context3, {
      'id': eventId
    }).remove();
  }

  deleteNewestBlocks(eventKey, gteBlockNum) {
    var _context4;

    if (gteBlockNum <= 0) return;
    const collection = this.db.getCollection(eventKey);
    if (collection) (0, _find.default)(_context4 = collection.chain()).call(_context4, {
      'blockNumber': {
        '$gte': gteBlockNum
      }
    }).remove();
  }

}

var _default = Database;
exports.default = _default;
//# sourceMappingURL=database.js.map