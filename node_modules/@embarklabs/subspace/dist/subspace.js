"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _mapInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/map");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));

var _setInterval2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-interval"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _database = _interopRequireDefault(require("./database/database.js"));

var _nullDatabase = _interopRequireDefault(require("./database/nullDatabase.js"));

var _events = _interopRequireDefault(require("events"));

var _web3Eth = _interopRequireDefault(require("web3-eth"));

var _utils = require("./utils");

var _stripHexPrefix = _interopRequireDefault(require("strip-hex-prefix"));

var _hex2dec = require("hex2dec");

var _eventSyncer = _interopRequireDefault(require("./eventSyncer"));

var _logSyncer = _interopRequireDefault(require("./logSyncer"));

var _objectHash = _interopRequireDefault(require("object-hash"));

class Subspace {
  constructor(provider, options = {}) {
    if (!provider.on) {
      // https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-subscriptions/src/subscription.js#L205
      console.warn("subspace: the current provider doesn't support subscriptions. Falling back to http polling");
    }

    this.events = new _events.default();
    this.web3 = new _web3Eth.default(provider);
    this.options = {};
    this.options.refreshLastNBlocks = options.refreshLastNBlocks || 12;
    this.options.callInterval = options.callInterval || 0;
    this.options.dbFilename = options.dbFilename || 'subspace.db';
    this.disableDatabase = options.disableDatabase;
    this.networkId = undefined;
    this.isWebsocketProvider = options.disableSubscriptions ? false : !!provider.on; // Stats

    this.latestBlockNumber = undefined;
    this.latestGasPrice = undefined;
    this.latestBlock = undefined;
    this.latest10Blocks = [];
    this.subjects = {};
    this.newBlocksSubscription = null;
    this.intervalTracker = null;
    this.callables = [];
  }

  init() {
    return new _promise.default(async (resolve, reject) => {
      if (this.disableDatabase === true) {
        this._db = new _nullDatabase.default("", this.events);
      } else {
        this._db = new _database.default(this.options.dbFilename, this.events);
      }

      this.eventSyncer = new _eventSyncer.default(this.web3, this.events, this._db, this.isWebsocketProvider);
      this.logSyncer = new _logSyncer.default(this.web3, this.events, this._db);
      this.web3.net.getId().then(netId => {
        this.networkId = netId;
      });
      const block = await this.web3.getBlock('latest');
      const gasPrice = await this.web3.getGasPrice(); // Preload <= 10 blocks to calculate avg block time

      if (block.number !== 0) {
        const minBlock = Math.max(0, block.number - 9);

        for (let i = minBlock; i < block.number; i++) {
          this.latest10Blocks.push(this.web3.getBlock(i));
        }

        this.latest10Blocks = await _promise.default.all(this.latest10Blocks);
      } // Initial stats


      this.latestBlockNumber = block.number;
      this.latestGasPrice = gasPrice;
      this.latestBlock = block;
      this.latest10Blocks.push(block);

      if (this.isWebsocketProvider) {
        this._initNewBlocksSubscription();
      } else {
        this.options.callInterval = this.options.callInterval || 1000;

        this._initCallInterval();
      }

      resolve();
    });
  }

  contract(contractInstance) {
    var _context, _context3;

    if (!contractInstance) {
      throw new Error("please pass a contract instance to Subspace.contract()");
    }

    let address = contractInstance.options && contractInstance.options.address || contractInstance.address || contractInstance.deployedAddress;
    let abi = contractInstance.options && contractInstance.options.jsonInterface || contractInstance.abi || contractInstance.abiDefinition;
    let from = contractInstance.options && contractInstance.options.from || contractInstance.from || contractInstance.defaultAddress || this.web3.defaultAccount;
    let gas = contractInstance.options && contractInstance.options.gas || contractInstance.gas || contractInstance.gas || "800000";
    const SubspaceContract = new this.web3.Contract(abi, {
      from,
      gas
    });
    SubspaceContract.options.address = address;
    SubspaceContract.options.from = from;

    if (!from) {
      (0, _setTimeout2.default)(async () => {
        const accounts = await this.web3.getAccounts();
        SubspaceContract.options.from = accounts[0];
      }, 100);
    }

    SubspaceContract.trackEvent = (eventName, filterConditionsOrCb) => {
      return this.trackEvent(SubspaceContract, eventName, filterConditionsOrCb);
    };

    (0, _forEach.default)(_context = (0, _keys.default)(SubspaceContract.events)).call(_context, ev => {
      var _context2;

      if (!(0, _find.default)(_context2 = SubspaceContract.options.jsonInterface).call(_context2, x => x.type === 'event' && x.name == ev)) return;

      SubspaceContract.events[ev].track = filterConditionsOrCb => this.trackEvent(SubspaceContract, ev, filterConditionsOrCb);
    });

    SubspaceContract.trackProperty = (propName, methodArgs, callArgs) => {
      return this.trackProperty(SubspaceContract, propName, methodArgs, callArgs);
    };

    (0, _forEach.default)(_context3 = (0, _keys.default)(SubspaceContract.methods)).call(_context3, methodName => {
      const oldFunc = SubspaceContract.methods[methodName];

      const _this = this;

      const newFunc = function () {
        const txObject = oldFunc.apply(null, arguments);

        txObject.track = callArgs => _this.trackProperty(SubspaceContract, methodName, txObject.arguments, callArgs);

        return txObject;
      };

      SubspaceContract.methods[methodName] = newFunc;
    });

    SubspaceContract.trackBalance = erc20Address => {
      return this.trackBalance(SubspaceContract.options.address, erc20Address);
    };

    return SubspaceContract;
  } // TODO: get contract abi/address instead


  trackEvent(contractInstance, eventName, filterConditions) {
    const subjectHash = (0, _objectHash.default)({
      address: contractInstance.options.address,
      networkId: this.networkId,
      eventName,
      filterConditions
    });
    if (this.subjects[subjectHash]) return this.subjects[subjectHash];
    let deleteFrom = this.latestBlockNumber - this.options.refreshLastNBlocks;
    let returnSub = this.eventSyncer.track(contractInstance, eventName, filterConditions, deleteFrom, this.networkId);

    returnSub.map = prop => {
      return returnSub.pipe((0, _mapInstanceProperty(_operators))(x => {
        if (typeof prop === "string") {
          return x[prop];
        }

        if ((0, _isArray.default)(prop)) {
          let newValues = {};
          (0, _forEach.default)(prop).call(prop, p => {
            newValues[p] = x[p];
          });
          return newValues;
        }
      }));
    };

    this.subjects[subjectHash] = returnSub;
    return returnSub;
  }

  clearDB(collection) {
    if (collection) {// TODO: delete specific collection
    } else {// TODO: delete everything
      }
  }

  trackLogs(options, inputsABI) {
    if (!this.isWebsocketProvider) console.warn("This method only works with websockets");
    const subjectHash = (0, _objectHash.default)({
      inputsABI,
      options
    });
    if (this.subjects[subjectHash]) return this.subjects[subjectHash];
    this.subjects[subjectHash] = this.logSyncer.track(options, inputsABI, this.latestBlockNumber - this.options.refreshLastNBlocks, this.networkId);
    return this.subjects[subjectHash];
  }

  _initNewBlocksSubscription() {
    if (this.newBlocksSubscription != null || this.options.callInterval !== 0) return;
    this.newBlocksSubscription = this.web3.subscribe('newBlockHeaders', (err, result) => {
      var _context4;

      if (err) {
        console.error(err);
        return;
      }

      (0, _forEach.default)(_context4 = this.callables).call(_context4, fn => {
        fn();
      });
    });
  }

  _initCallInterval() {
    if (this.intervalTracker != null || this.options.callInterval === 0) return;
    this.intervalTracker = (0, _setInterval2.default)(() => {
      var _context5;

      (0, _forEach.default)(_context5 = this.callables).call(_context5, fn => {
        fn();
      });
    }, this.options.callInterval);
  }

  trackProperty(contractInstance, propName, methodArgs = [], callArgs = {}) {
    const subjectHash = (0, _objectHash.default)({
      address: contractInstance.options.address,
      networkId: this.networkId,
      propName,
      methodArgs,
      callArgs
    });
    if (this.subjects[subjectHash]) return this.subjects[subjectHash];
    const subject = new _rxjs.Subject();

    if (!(0, _isArray.default)(methodArgs)) {
      methodArgs = [methodArgs];
    }

    const method = contractInstance.methods[propName].apply(contractInstance.methods[propName], methodArgs);

    const callContractMethod = () => {
      method.call.apply(method.call, [callArgs, (err, result) => {
        if (err) {
          subject.error(err);
          return;
        }

        subject.next(result);
      }]);
    };

    callContractMethod();
    this.callables.push(callContractMethod);
    const returnSub = subject.pipe((0, _operators.distinctUntilChanged)((a, b) => (0, _fastDeepEqual.default)(a, b)));

    returnSub.map = prop => {
      return returnSub.pipe((0, _mapInstanceProperty(_operators))(x => {
        if (typeof prop === "string") {
          return x[prop];
        }

        if ((0, _isArray.default)(prop)) {
          let newValues = {};
          (0, _forEach.default)(prop).call(prop, p => {
            newValues[p] = x[p];
          });
          return newValues;
        }
      }));
    };

    this.subjects[subjectHash] = returnSub;
    return returnSub;
  }

  _addDistinctCallable(trackAttribute, cbBuilder, subject, subjectArg = undefined) {
    if (this.subjects[trackAttribute]) return this.subjects[trackAttribute];
    const sub = new subject(subjectArg);
    const cb = cbBuilder(sub);
    cb();
    this.callables.push(cb);
    this.subjects[trackAttribute] = sub.pipe((0, _operators.distinctUntilChanged)((a, b) => (0, _fastDeepEqual.default)(a, b)));
    return this.subjects[trackAttribute];
  }

  trackBlock() {
    const blockCB = subject => () => {
      this.web3.getBlock('latest').then(block => {
        if (this.latest10Blocks[this.latest10Blocks.length - 1].number === block.number) return;
        this.latest10Blocks.push(block);

        if (this.latest10Blocks.length > 10) {
          this.latest10Blocks.shift();
        }

        subject.next(block);
      }).catch(error => subject.error(error));
    };

    return this._addDistinctCallable('blockObservable', blockCB, _rxjs.BehaviorSubject, this.latestBlock);
  }

  trackBlockNumber() {
    const blockNumberCB = subject => () => {
      this.web3.getBlockNumber().then(blockNumber => subject.next(blockNumber)).catch(error => subject.error(error));
    };

    return this._addDistinctCallable('blockNumberObservable', blockNumberCB, _rxjs.BehaviorSubject, this.latestBlockNumber);
  }

  trackGasPrice() {
    const gasPriceCB = subject => () => {
      this.web3.getGasPrice().then(gasPrice => subject.next(gasPrice)).catch(error => subject.error(error));
    };

    return this._addDistinctCallable('gasPriceObservable', gasPriceCB, _rxjs.BehaviorSubject, this.latestGasPrice);
  }

  trackAverageBlocktime() {
    this.trackBlock();

    const avgTimeCB = subject => () => {
      const times = [];

      for (let i = 1; i < this.latest10Blocks.length; i++) {
        let time = this.latest10Blocks[i].timestamp - this.latest10Blocks[i - 1].timestamp;
        times.push(time);
      }

      const average = times.length ? Math.round((0, _reduce.default)(times).call(times, (a, b) => a + b) / times.length) * 1000 : 0;
      subject.next(average);
    };

    return this._addDistinctCallable('blockTimeObservable', avgTimeCB, _rxjs.BehaviorSubject, 123456);
  }

  trackBalance(address, erc20Address) {
    const sub = new _rxjs.ReplaySubject();
    if (!(0, _utils.isAddress)(address)) throw "invalid address";
    if (erc20Address && !(0, _utils.isAddress)(erc20Address)) throw "invalid ERC20 contract address";
    let callFn;

    if (!erc20Address) {
      callFn = () => {
        const fn = this.web3.getBalance;
        fn.apply(fn, [address, (err, balance) => {
          if (err) {
            sub.error(err);
            return;
          }

          sub.next(balance);
        }]);
      };
    } else {
      callFn = () => {
        const fn = this.web3.call; //  balanceOf

        const data = "0x70a08231" + "000000000000000000000000" + (0, _stripHexPrefix.default)(address);
        fn.apply(fn, [{
          to: erc20Address,
          data
        }, (err, result) => {
          if (err) {
            sub.error(err);
            return;
          }

          sub.next((0, _hex2dec.hexToDec)(result));
        }]);
      };
    } // FIX ME: has issues immediatly getting the value
    // this.web3.getBlock('latest').then(block => {


    (0, _setTimeout2.default)(() => {
      callFn();
    }, 500); // });

    this.callables.push(callFn);
    return sub.pipe((0, _operators.distinctUntilChanged)((a, b) => (0, _fastDeepEqual.default)(a, b)));
  }

  close() {
    clearInterval(this.intervalTracker);
    if (this.newBlocksSubscription) this.newBlocksSubscription.unsubscribe();
    this.eventSyncer.close();
    this.intervalTracker = null;
    this.callables = [];
  }

}

exports.default = Subspace;
//# sourceMappingURL=subspace.js.map