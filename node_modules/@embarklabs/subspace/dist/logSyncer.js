"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _rxjs = require("rxjs");

var _objectHash = _interopRequireDefault(require("object-hash"));

class LogSyncer {
  constructor(web3, events, db) {
    (0, _defineProperty2.default)(this, "_parseEventCBFactory", (filterConditions, eventKey) => (err, ev) => {
      if (err) {
        throw new Error(err);
      }

      if (filterConditions) {
        if (filterConditions.address && ev.address.toLowerCase() !== filterConditions.address.toLowerCase()) return;

        if (filterConditions.topics) {
          var _context;

          let shouldSkip = false;
          (0, _forEach.default)(_context = filterConditions.topics).call(_context, (topic, i) => {
            if (topic != null && (!ev.topics[i] || ev.topics[i].toLowerCase() !== topic.toLowerCase())) {
              shouldSkip = true;
            }
          });
          if (shouldSkip) return;
        }
      }

      this.events.emit(eventKey, ev);
    });
    this.events = events;
    this.web3 = web3;
    this.db = db;
    this.subscriptions = [];
  }

  track(options, inputsABI, gteBlockNum, networkId) {
    const eventKey = 'logs-' + (0, _objectHash.default)((0, _assign.default)({
      networkId
    }, options || {}));
    const filterConditions = (0, _assign.default)({
      fromBlock: 0,
      toBlock: "latest"
    }, options || {});
    this.db.deleteNewestBlocks(eventKey, gteBlockNum);
    const eventSummary = this.db.getLastKnownEvent(eventKey);
    const sub = new _rxjs.ReplaySubject();
    const logObserver = (0, _rxjs.fromEvent)(this.events, eventKey);
    logObserver.subscribe(e => {
      if (!e) return;
      const id = (0, _objectHash.default)({
        eventName: eventKey,
        blockNumber: e.blockNumber,
        transactionIndex: e.transactionIndex,
        logIndex: e.logIndex
      }); // TODO: would be nice if this was smart enough to understand the type of returnValues and do the needed conversions

      const eventData = {
        id: (0, _objectHash.default)({
          eventName: eventKey,
          blockNumber: e.blockNumber,
          transactionIndex: e.transactionIndex,
          logIndex: e.logIndex
        }),
        data: e.data,
        address: e.address,
        topics: e.topics,
        removed: e.removed
      };
      const obsData = {
        blockNumber: e.blockNumber,
        data: e.data,
        address: e.address,
        topics: e.topics
      };

      if (inputsABI) {
        var _context2;

        eventData.returnValues = web3.eth.abi.decodeLog(inputsABI, e.data, (0, _slice.default)(_context2 = e.topics).call(_context2, 1));
        obsData.returnValues = eventData.returnValues;
      } // TODO: test reorgs


      sub.next(obsData);

      if (e.removed) {
        this.db.deleteEvent(eventKey, id);
        return;
      }

      if (this.db.eventExists(eventKey, eventData.id)) return;
      this.db.recordEvent(eventKey, eventData);
      this.events.emit("updateDB");
    });

    const eth_subscribe = this._retrieveEvents(eventKey, eventSummary.firstKnownBlock, eventSummary.lastKnownBlock, filterConditions);

    const og_subscribe = sub.subscribe;

    sub.subscribe = (next, error, complete) => {
      const s = og_subscribe.apply(sub, [next, error, complete]);
      s.add(() => {
        // Removing web3js subscription when rxJS unsubscribe is executed
        if (eth_subscribe) eth_subscribe.unsubscribe();
      });
      return s;
    };

    return sub;
  }

  _retrieveEvents(eventKey, firstKnownBlock, lastKnownBlock, filterConditions) {
    // TODO: this should be moved to a 'smart' module
    // it should be able to do events X at the time to avoid slow downs as well as the 10k limit
    if (firstKnownBlock == 0 || firstKnownBlock > 0 && firstKnownBlock <= filterConditions.fromBlock) {
      if (filterConditions.toBlock === 'latest') {
        // emit DB Events [fromBlock, lastKnownBlock]
        this._serveDBEvents(eventKey, filterConditions.fromBlock, lastKnownBlock, filterConditions); // create a event subscription [lastKnownBlock + 1, ...]


        let filters = (0, _assign.default)({}, filterConditions, {
          fromBlock: filterConditions.fromBlock > lastKnownBlock ? filterConditions.fromBlock : lastKnownBlock + 1
        });
        return this._subscribeToEvent(filters, eventKey);
      } else if (filterConditions.toBlock <= lastKnownBlock) {
        // emit DB Events [fromBlock, toBlock]
        this._serveDBEvents(eventKey, filterConditions.fromBlock, filterConditions.toBlock, filterConditions);
      } else {
        // emit DB Events [fromBlock, lastKnownBlock]
        this._serveDBEvents(eventKey, filterConditions.fromBlock, lastKnownBlock, filterConditions); // create a past event subscription [lastKnownBlock + 1, toBlock]


        let filters = (0, _assign.default)({}, filterConditions, {
          fromBlock: filterConditions.fromBlock > lastKnownBlock ? filterConditions.fromBlock : lastKnownBlock + 1
        });

        this._getPastEvents(filters, eventKey);
      }
    } else if (firstKnownBlock > 0) {
      // create a past event subscription [ firstKnownBlock > fromBlock ? fromBlock : 0, firstKnownBlock - 1]
      let fromBlock = firstKnownBlock > filterConditions.fromBlock ? filterConditions.fromBlock : 0;
      let filters = (0, _assign.default)({}, filterConditions, {
        fromBlock,
        toBlock: firstKnownBlock - 1
      });

      this._getPastEvents(filters, eventKey);

      if (filterConditions.toBlock === 'latest') {
        // emit DB Events [firstKnownBlock, lastKnownBlock]
        this._serveDBEvents(eventKey, firstKnownBlock, lastKnownBlock, filterConditions); // create a subscription [lastKnownBlock + 1, ...]


        const filters = (0, _assign.default)({}, filterConditions, {
          fromBlock: lastKnownBlock + 1
        });
        return this._subscribeToEvent(filters, eventKey);
      } else if (filterConditions.toBlock <= lastKnownBlock) {
        // emit DB Events [fromBlock, toBlock]
        this._serveDBEvents(eventKey, filterConditions.fromBlock, filterConditions.toBlock, filterConditions);
      } else {
        // emit DB Events [fromBlock, lastKnownBlock]
        this._serveDBEvents(eventKey, filterConditions.fromBlock, lastKnownBlock, filterConditions); // create a past event subscription [lastKnownBlock + 1, toBlock]


        let filters = (0, _assign.default)({}, filterConditions, {
          fromBlock: lastKnownBlock + 1,
          toBlock: filterConditions.toBlock
        });

        this._getPastEvents(filters, eventKey);
      }
    }
  }

  _serveDBEvents(eventKey, firstKnownBlock, lastKnownBlock, filterConditions) {
    var _context3;

    const cb = this._parseEventCBFactory(filterConditions, eventKey);

    const storedEvents = (0, _filter.default)(_context3 = this.db.getEventsFor(eventKey)).call(_context3, x => x.blockNumber >= firstKnownBlock && x.blockNumber <= lastKnownBlock);
    (0, _forEach.default)(storedEvents).call(storedEvents, ev => {
      cb(null, ev);
    });
  }

  _getPastEvents(filterConditions, eventKey) {
    const cb = this._parseEventCBFactory(filterConditions, eventKey);

    this.web3.getPastLogs(options, (err, logs) => {
      if (err) {
        throw new Error(err);
      }

      (0, _forEach.default)(logs).call(logs, l => {
        cb(null, l);
      });
    });
  }

  _subscribeToEvent(filterConditions, eventKey) {
    const s = this.web3.subscribe('logs', filterConditions, this._parseEventCBFactory(filterConditions, eventKey));
    this.subscriptions.push(s);
    return s;
  }

  close() {
    var _context4;

    (0, _forEach.default)(_context4 = this.subscriptions).call(_context4, x => {
      x.unsubscribe();
    });
  }

}

var _default = LogSyncer;
exports.default = _default;
//# sourceMappingURL=logSyncer.js.map