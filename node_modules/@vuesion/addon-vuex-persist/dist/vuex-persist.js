"use strict";
/**
 * inspired by https://github.com/robinvdvleuten/vuex-persistedstate
 */
Object.defineProperty(exports, "__esModule", { value: true });
const merge = require("deepmerge");
const canWriteStorage = (storage) => {
    try {
        storage.setItem('@@', '1');
        storage.removeItem('@@');
        return true;
    }
    catch (e) {
        return false;
    }
};
const getState = (key, storage) => {
    try {
        const value = storage.getItem(key);
        return value && value !== 'undefined' ? JSON.parse(value) : undefined;
    }
    catch (e) {
        return undefined;
    }
};
const setState = (key, state, storage) => {
    return storage.setItem(key, JSON.stringify(state));
};
const subscriber = (store) => {
    return (handler) => {
        return store.subscribe(handler);
    };
};
const processStorage = (storage, vuexStore) => {
    const mergeOptions = {
        clone: false,
        arrayMerge: (target, source) => {
            return source;
        },
    };
    storage.modules.forEach((key) => {
        const savedState = getState(key, storage);
        if (savedState && Object.keys(savedState).length > 0) {
            vuexStore.state[key] = storage.forceInitialState
                ? merge(savedState, vuexStore.state[key], mergeOptions)
                : merge(vuexStore.state[key], savedState, mergeOptions);
        }
        subscriber(vuexStore)((mutation, state) => {
            state = storage.beforePersist(JSON.parse(JSON.stringify(state)));
            setState(key, state[key], storage);
        });
    });
};
exports.VuexPersist = (storages) => {
    return (vuexStore) => {
        storages.forEach((storage) => {
            if (canWriteStorage(storage)) {
                processStorage(storage, vuexStore);
            }
        });
        vuexStore.replaceState(vuexStore.state);
    };
};
