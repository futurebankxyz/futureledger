"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("../decorators/command");
const ramda_1 = require("ramda");
const fs = require("fs");
const path_1 = require("@vuesion/utils/dist/path");
const ui_1 = require("@vuesion/utils/dist/ui");
const spawn = require('cross-spawn');
const opn = require('open');
const getDate = (date) => {
    const newDate = new Date(date);
    newDate.setHours(newDate.getHours() + 1);
    newDate.setMinutes(newDate.getMinutes() + 4);
    return newDate
        .toISOString()
        .slice(0, 10)
        .replace('T', ' ');
};
const getType = (message) => {
    const type = message.split(':');
    return type.length === 1 ? 'feat' : type[0].trim().replace(/\(.*\)/g, '');
};
const reportTemplate = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Report</title>
</head>

<body>
  <canvas id="myChart" width="100%" height="50%"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.min.js"></script>
  <script>
  var ctx = document.getElementById("myChart").getContext("2d")
  var myChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: <dates>,
      datasets: <report>
    },
			options: {
        animation: {
            duration: 0, // general animation time
        },
        hover: {
            animationDuration: 0, // duration of animations when hovering an item
        },
        responsiveAnimationDuration: 0,
				scales: {
					xAxes: [{
						type: 'time',
						distribution: 'series',
						ticks: {
							source: 'labels'
						}
					}],
					yAxes: [{
					  stacked: true,
					}]
				},
        elements: {
            line: {
                tension: 0
            }
        }
			}
  });
  </script>
</body>
</html>`;
const getColor = (type) => {
    const colors = {
        build: '#845EC2',
        ci: '#f9d10f',
        docs: '#005d50',
        feat: '#00f401',
        fix: '#ff4f56',
        perf: '#00fea9',
        refactor: '#ff90dd',
        style: '#ffa238',
        test: '#009735',
        chore: '#626262',
        numberOfCommits: '#549dd8',
        numberOfReleases: '#192633',
    };
    return colors[type];
};
let Statistics = class Statistics {
    async run() {
        const childProcess = spawn('git', ['log', 'master', '--pretty=format:"%T|%s|%an|%cd"'], {});
        const stats = [];
        const types = [];
        const dates = [];
        const report = {};
        const reportPath = path_1.packagesRoot('service', 'dist/report.html');
        childProcess.stdout.on('data', (data) => {
            data
                .toString()
                .split(/\r?\n/)
                .forEach((line) => {
                if (line.trim().length === 0) {
                    return;
                }
                const [hash, message, author, date] = line.replace(/"/g, '').split('|');
                const type = getType(message);
                const formattedDate = getDate(date);
                const release = message.indexOf(':') === -1 && message.indexOf('.') > -1;
                stats.push({ hash, message, author, date: formattedDate, type, release });
                if (types.indexOf(type) === -1) {
                    types.push(type);
                }
                if (dates.indexOf(formattedDate) === -1) {
                    dates.push(formattedDate);
                }
            });
        });
        const chart = [];
        childProcess.on('exit', () => {
            dates.forEach((date) => {
                const statsForDate = ramda_1.filter(ramda_1.where({ date: ramda_1.equals(date) }), stats);
                const countPerType = {};
                const numberOfReleases = ramda_1.filter(ramda_1.where({ release: ramda_1.equals(true) }), statsForDate).length;
                let numberOfCommits = 0;
                types.forEach((type) => {
                    const count = ramda_1.filter(ramda_1.where({ type: ramda_1.equals(type), release: ramda_1.equals(false) }), statsForDate).length;
                    countPerType[type] = count;
                    numberOfCommits += count;
                });
                report[date] = { ...countPerType, numberOfCommits, numberOfReleases };
            });
            [...types, 'numberOfCommits', 'numberOfReleases'].forEach((type) => {
                const color = getColor(type);
                const set = {
                    label: type,
                    backgroundColor: color,
                    borderColor: color,
                    data: [],
                    fill: true,
                };
                dates.forEach((date) => {
                    set.data.push(report[date][type]);
                });
                chart.push(set);
            });
            const file = reportTemplate.replace('<dates>', JSON.stringify(dates)).replace('<report>', JSON.stringify(chart));
            fs.writeFileSync(reportPath, file, 'utf-8');
            opn(reportPath, {
                wait: false,
            }).catch((err) => ui_1.logErrorBold(err));
        });
    }
};
Statistics = __decorate([
    command_1.Command({
        name: 'statistics',
        alias: 's',
        description: 'Generates a report for certain project management KPIs.',
    })
], Statistics);
exports.Statistics = Statistics;
