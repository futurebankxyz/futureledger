"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const vue_server_renderer_1 = require("vue-server-renderer");
const ramda_1 = require("ramda");
const command_1 = require("../decorators/command");
const process_1 = require("@vuesion/utils/dist/process");
const ui_1 = require("@vuesion/utils/dist/ui");
const path_1 = require("@vuesion/utils/dist/path");
const fileSystem_1 = require("@vuesion/utils/dist/fileSystem");
const rimraf_1 = require("rimraf");
const models_1 = require("@vuesion/models");
let Build = class Build {
    async run(args, options) {
        process.env.NODE_ENV = 'production';
        rimraf_1.sync('./dist');
        if (this.analyze) {
            analyze(options);
        }
        else if (this.spa) {
            spa(options);
        }
        else {
            build(options);
        }
    }
};
Build = __decorate([
    command_1.Command({
        name: 'build',
        alias: 'b',
        description: 'Build project for production.',
        options: [
            { flags: '-a, --analyze', description: 'Analyze client bundle.' },
            { flags: '-spa, --spa', description: 'Build only client-side application and renders static HTML content.' },
        ],
    })
], Build);
exports.Build = Build;
const runWebpack = (configName, options) => {
    const configPath = path_1.packagesRoot('webpack', `dist/config/${configName}.js`);
    return process_1.runProcess('node', [path_1.packagesRoot('webpack', 'dist/scripts/run-webpack.js'), configPath, 'production', `${options.debug}`], { silent: true, ...options });
};
const build = async (options) => {
    const promises = [];
    const startTime = Date.now();
    const spinner = new ui_1.Spinner();
    let done = 0;
    const setSpinnerMessage = () => {
        if (done === 3) {
            spinner.message = `Finished building universal application in ${Date.now() - startTime}ms`;
        }
        else {
            spinner.message = `Building universal application ${done}/3 ...`;
        }
    };
    spinner.start(options.debug);
    setSpinnerMessage();
    const run = (configName) => {
        promises.push(runWebpack(configName, options).then(() => {
            done = done + 1;
            setSpinnerMessage();
        }));
    };
    run('client');
    run('server');
    run('isomorphic');
    try {
        await Promise.all(promises);
        spinner.stop();
    }
    catch (e) {
        process_1.handleProcessError(e, spinner);
    }
};
const analyze = async (options) => {
    process.env.ANALYZE = 'true';
    const startTime = Date.now();
    const spinner = new ui_1.Spinner();
    spinner.start(options.debug);
    spinner.message = `Analyzing application bundle...`;
    try {
        await runWebpack('client', options);
    }
    catch (e) {
        process_1.handleProcessError(e, spinner);
    }
    spinner.message = `Analysis finished in ${Date.now() - startTime}ms`;
    spinner.stop();
};
const renderPage = async (renderer, route) => {
    return renderer.renderToString({
        url: route,
        cookies: {},
        acceptLanguage: models_1.VuesionConfig.i18n.defaultLocale,
        htmlLang: models_1.VuesionConfig.i18n.defaultLocale.substr(0, 2),
        appConfig: {},
        redirect: null,
    });
};
const spaCleanUp = async (options) => {
    await process_1.runProcess('rimraf', ['./dist/server'], {
        silent: true,
        ...options,
    });
};
const renderPages = async (options) => {
    const renderer = vue_server_renderer_1.createBundleRenderer(path_1.runtimeRoot('dist/server/vue-ssr-bundle.json'), {
        template: fs.readFileSync(path_1.runtimeRoot('dist/index.html')).toString(),
    });
    const appShellRoute = ramda_1.pathOr('/', ['spa', 'appShellRoute'], models_1.VuesionConfig);
    const routes = ramda_1.pathOr([], ['spa', 'additionalRoutes'], models_1.VuesionConfig);
    routes.unshift(appShellRoute);
    for (const route of routes) {
        const filename = route === appShellRoute ? '/index.html' : `${route}.html`;
        const filePath = path_1.runtimeRoot(`dist${filename}`);
        try {
            const html = await renderPage(renderer, route);
            fileSystem_1.ensureDirectoryExists(filePath);
            fs.writeFileSync(filePath, html, 'utf-8');
        }
        catch (e) {
            e.route = route;
            throw e;
        }
    }
    await spaCleanUp(options);
};
const handleRenderError = (e, spinner) => {
    spinner.stop(true);
    ui_1.logInfoBold(`Error during rendering ${e.route}`);
    if (e.code && e.code === 302) {
        ui_1.logInfo('This route probably has a route guard and can not be rendered to static HTML.');
    }
    else if (e.code && e.code === 404) {
        ui_1.logInfo('This route does not exist and can not be rendered to static HTML.');
    }
    else {
        ui_1.logInfo(e.message);
    }
};
const spa = async (options) => {
    const startTime = Date.now();
    const spinner = new ui_1.Spinner();
    spinner.start(options.debug);
    spinner.message = `Building client-side application and render static HTML...`;
    try {
        await Promise.all([runWebpack('isomorphic', options), runWebpack('spa', options)]);
    }
    catch (e) {
        process_1.handleProcessError(e, spinner);
        return;
    }
    try {
        spinner.message = `Rendering static HTML...`;
        await renderPages(options);
    }
    catch (e) {
        handleRenderError(e, spinner);
        return;
    }
    spinner.message = `Production build finished in ${Date.now() - startTime}ms`;
    spinner.stop();
};
