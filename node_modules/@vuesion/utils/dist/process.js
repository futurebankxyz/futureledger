"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ui_1 = require("./ui");
const spawn = require('cross-spawn');
const signals = [
    'SIGHUP',
    'SIGINT',
    'SIGQUIT',
    'SIGUSR1',
    'SIGUSR2',
    'SIGTERM',
    'SIGCONT',
    'SIGILL',
    'SIGTRAP',
    'SIGABRT',
    'SIGBUS',
    'SIGFPE',
    'SIGSEGV',
    'SIGPIPE',
    'SIGALRM',
    'SIGTSTP',
    'SIGTTIN',
    'SIGTTOU',
    'SIGPROF',
    'SIGSYS',
    'uncaughtException',
];
const processes = [];
const killProcesses = () => {
    processes.forEach((p) => {
        p.kill();
    });
    process.exit(1);
};
signals.forEach((signal) => {
    process.on(signal, () => killProcesses());
});
exports.runProcess = (name, args = [], options) => {
    return new Promise((resolve, reject) => {
        options = Object.assign({ cwd: process.cwd(), silent: false, debug: false }, options);
        const localOptions = Object.assign({
            detached: false,
            cwd: options.cwd,
            env: process.env,
        }, options.silent === false || options.debug === true ? { stdio: 'inherit' } : {});
        const childProcess = spawn(name, args, localOptions);
        childProcess.on('exit', (code) => {
            if (code === 0) {
                resolve(undefined);
            }
            else {
                const err = { code, trace: '' };
                reject(err);
            }
        });
        childProcess.on('error', (e) => {
            const err = { code: e.code, trace: e.toString() };
            reject(err);
        });
        processes.push(childProcess);
    });
};
exports.handleProcessError = (err, spinner = null) => {
    if (spinner) {
        spinner.stop(true);
    }
    ui_1.logError(`Exit with error code: ${err.code}\n\nTrace:\n${err.trace}`);
    killProcesses();
    process.exit(err.code);
};
